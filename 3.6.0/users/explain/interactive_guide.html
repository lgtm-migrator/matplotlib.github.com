
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Interactive figures and asynchronous programming &#8212; Matplotlib 3.6.0rc1 documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/style.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mpl.css?v3.6.0rc1-4-gf7130cd5c7" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/design-tabs.js"></script>
    <script async="async" src="https://www.google-analytics.com/analytics.js"></script>
    <script>
                window.ga = window.ga || function () {
                    (ga.q = ga.q || []).push(arguments) };
                ga.l = +new Date;
                ga('create', 'UA-55954603-1', 'auto');
                ga('set', 'anonymizeIp', true);
                ga('send', 'pageview');
            </script>
    <link rel="canonical" href="https://matplotlib.org/stable/users/explain/interactive_guide.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.6.0rc1 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="How-to and troubleshooting" href="../faq/index.html" />
    <link rel="prev" title="Performance" href="performance.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../../_static/logo2.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        
<ul id="navbar-main-elements" class="navbar-nav">
  <li class="nav-item">
    <a class="reference internal nav-link" href="../../plot_types/index.html">Plot types</a>
  </li>
  <li class="nav-item">
    <a class="reference internal nav-link" href="../../gallery/index.html">Examples</a>
  </li>
  <li class="nav-item">
    <a class="reference internal nav-link" href="../../tutorials/index.html">Tutorials</a>
  </li>
  <li class="nav-item">
    <a class="reference internal nav-link" href="../../api/index.html">Reference</a>
  </li>
  <li class="nav-item">
    <a class="reference internal nav-link" href="../index.html">User guide</a>
  </li>
  <li class="nav-item">
    <a class="reference internal nav-link" href="../../devel/index.html">Develop</a>
  </li>
  <li class="nav-item">
    <a class="reference internal nav-link" href="../release_notes.html">Release notes</a>
  </li>
</ul>

      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        devdocs  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables users/explain/interactive_guide and {'json_url': 'https://matplotlib.org/devdocs/_static/switcher.json', 'version_match': 'devdocs'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "users/explain/interactive_guide.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://matplotlib.org/devdocs/_static/switcher.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "users/explain/interactive_guide.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 3.6.0rc1 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "devdocs") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        
      <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://gitter.im/matplotlib" rel="noopener" target="_blank" title="gitter">
            <span><i class="fab fa-gitter"></i></span>
            <label class="sr-only">gitter</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://discourse.matplotlib.org" rel="noopener" target="_blank" title="discourse">
            <span><i class="fab fa-discourse"></i></span>
            <label class="sr-only">discourse</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/matplotlib/matplotlib" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/matplotlib/" rel="noopener" target="_blank" title="twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="api_interfaces.html">
   Matplotlib Application Interfaces (APIs)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="backends.html">
   Backends
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="interactive.html">
   Interactive figures
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="simple">
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fonts.html">
   Fonts in Matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="event_handling.html">
   Event handling and picking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="performance.html">
   Performance
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Interactive figures and asynchronous programming
  </a>
 </li>
</ul>

  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#event-loops">
   Event loops
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#command-prompt-integration">
   Command prompt integration
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#blocking-the-prompt">
     Blocking the prompt
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#input-hook-integration">
     Input hook integration
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#full-embedding">
   Full embedding
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#scripts-and-functions">
   Scripts and functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#blocking-functions">
     Blocking functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#explicitly-spinning-the-event-loop">
     Explicitly spinning the event Loop
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#stale-artists">
   Stale artists
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#draw-idle">
   Idle draw
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#threading">
   Threading
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eventloop-integration-mechanism">
   Eventloop integration mechanism
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cpython-readline">
     CPython / readline
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ipython-prompt-toolkit">
     IPython / prompt_toolkit
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="interactive-figures-and-asynchronous-programming">
<span id="interactive-figures-and-eventloops"></span><h1>Interactive figures and asynchronous programming<a class="headerlink" href="#interactive-figures-and-asynchronous-programming" title="Permalink to this heading">#</a></h1>
<p>Matplotlib supports rich interactive figures by embedding figures into
a GUI window.  The basic interactions of panning and zooming in an
Axes to inspect your data is 'baked in' to Matplotlib.  This is
supported by a full mouse and keyboard event handling system that
you can use to build sophisticated interactive graphs.</p>
<p>This guide is meant to be an introduction to the low-level details of
how Matplotlib integration with a GUI event loop works.  For a more
practical introduction to the Matplotlib event API see <a class="reference internal" href="event_handling.html#event-handling-tutorial"><span class="std std-ref">event
handling system</span></a>, <a class="reference external" href="https://github.com/matplotlib/interactive_tutorial">Interactive Tutorial</a>, and
<a class="reference external" href="http://www.amazon.com/Interactive-Applications-using-Matplotlib-Benjamin/dp/1783988843">Interactive Applications using Matplotlib</a>.</p>
<section id="event-loops">
<h2>Event loops<a class="headerlink" href="#event-loops" title="Permalink to this heading">#</a></h2>
<p>Fundamentally, all user interaction (and networking) is implemented as
an infinite loop waiting for events from the user (via the OS) and
then doing something about it.  For example, a minimal Read Evaluate
Print Loop (REPL) is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exec_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">exec_count</span><span class="si">}</span><span class="s2">] &gt; &quot;</span><span class="p">)</span>        <span class="c1"># Read</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>                          <span class="c1"># Evaluate</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>                               <span class="c1"># Print</span>
    <span class="n">exec_count</span> <span class="o">+=</span> <span class="mi">1</span>                          <span class="c1"># Loop</span>
</pre></div>
</div>
<p>This is missing many niceties (for example, it exits on the first
exception!), but is representative of the event loops that underlie
all terminals, GUIs, and servers <a class="footnote-reference brackets" href="#f1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.  In general the <em>Read</em> step
is waiting on some sort of I/O -- be it user input or the network --
while the <em>Evaluate</em> and <em>Print</em> are responsible for interpreting the
input and then <strong>doing</strong> something about it.</p>
<p>In practice we interact with a framework that provides a mechanism to
register callbacks to be run in response to specific events rather
than directly implement the I/O loop <a class="footnote-reference brackets" href="#f2" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.  For example &quot;when the
user clicks on this button, please run this function&quot; or &quot;when the
user hits the 'z' key, please run this other function&quot;.  This allows
users to write reactive, event-driven, programs without having to
delve into the nitty-gritty <a class="footnote-reference brackets" href="#f3" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> details of I/O.  The core event loop
is sometimes referred to as &quot;the main loop&quot; and is typically started,
depending on the library, by methods with names like <code class="docutils literal notranslate"><span class="pre">_exec</span></code>,
<code class="docutils literal notranslate"><span class="pre">run</span></code>, or <code class="docutils literal notranslate"><span class="pre">start</span></code>.</p>
<p>All GUI frameworks (Qt, Wx, Gtk, tk, OSX, or web) have some method of
capturing user interactions and passing them back to the application
(for example <code class="docutils literal notranslate"><span class="pre">Signal</span></code> / <code class="docutils literal notranslate"><span class="pre">Slot</span></code> framework in Qt) but the exact
details depend on the toolkit.  Matplotlib has a <a class="reference internal" href="backends.html#what-is-a-backend"><span class="std std-ref">backend</span></a> for each GUI toolkit we support which uses the
toolkit API to bridge the toolkit UI events into Matplotlib's <a class="reference internal" href="event_handling.html#event-handling-tutorial"><span class="std std-ref">event
handling system</span></a>.  You can then use
<a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FigureCanvasBase.mpl_connect</span></code></a> to connect your function to
Matplotlib's event handling system.  This allows you to directly
interact with your data and write GUI toolkit agnostic user
interfaces.</p>
</section>
<section id="command-prompt-integration">
<span id="cp-integration"></span><h2>Command prompt integration<a class="headerlink" href="#command-prompt-integration" title="Permalink to this heading">#</a></h2>
<p>So far, so good.  We have the REPL (like the IPython terminal) that
lets us interactively send code to the interpreter and get results
back.  We also have the GUI toolkit that runs an event loop waiting
for user input and lets us register functions to be run when that
happens.  However, if we want to do both we have a problem: the prompt
and the GUI event loop are both infinite loops that each think <em>they</em>
are in charge!  In order for both the prompt and the GUI windows to be
responsive we need a method to allow the loops to 'timeshare' :</p>
<ol class="arabic simple">
<li><p>let the GUI main loop block the python process when you want
interactive windows</p></li>
<li><p>let the CLI main loop block the python process and intermittently
run the GUI loop</p></li>
<li><p>fully embed python in the GUI (but this is basically writing a full
application)</p></li>
</ol>
<section id="blocking-the-prompt">
<span id="cp-block-the-prompt"></span><h3>Blocking the prompt<a class="headerlink" href="#blocking-the-prompt" title="Permalink to this heading">#</a></h3>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.show.html#matplotlib.pyplot.show" title="matplotlib.pyplot.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.show</span></code></a></p></td>
<td><p>Display all open figures.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.pause.html#matplotlib.pyplot.pause" title="matplotlib.pyplot.pause"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.pause</span></code></a></p></td>
<td><p>Run the GUI event loop for <em>interval</em> seconds.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.start_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.start_event_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.start_event_loop</span></code></a></p></td>
<td><p>Start a blocking event loop.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.stop_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.stop_event_loop</span></code></a></p></td>
<td><p>Stop the current blocking event loop.</p></td>
</tr>
</tbody>
</table>
<p>The simplest &quot;integration&quot; is to start the GUI event loop in
'blocking' mode and take over the CLI.  While the GUI event loop is
running you can not enter new commands into the prompt (your terminal
may echo the characters typed into the terminal, but they will not be
sent to the Python interpreter because it is busy running the GUI
event loop), but the figure windows will be responsive.  Once the
event loop is stopped (leaving any still open figure windows
non-responsive) you will be able to use the prompt again.  Re-starting
the event loop will make any open figure responsive again (and will
process any queued up user interaction).</p>
<p>To start the event loop until all open figures are closed, use
<a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.show.html#matplotlib.pyplot.show" title="matplotlib.pyplot.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.show</span></code></a> as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>To start the event loop for a fixed amount of time (in seconds) use
<a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.pause.html#matplotlib.pyplot.pause" title="matplotlib.pyplot.pause"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.pause</span></code></a>.</p>
<p>If you are not using <a class="reference internal" href="../../api/pyplot_summary.html#module-matplotlib.pyplot" title="matplotlib.pyplot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot</span></code></a> you can start and stop the event loops
via <a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.start_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.start_event_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FigureCanvasBase.start_event_loop</span></code></a> and
<a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.stop_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FigureCanvasBase.stop_event_loop</span></code></a>. However, in most contexts where
you would not be using <a class="reference internal" href="../../api/pyplot_summary.html#module-matplotlib.pyplot" title="matplotlib.pyplot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot</span></code></a> you are embedding Matplotlib in a
large GUI application and the GUI event loop should already be running
for the application.</p>
<p>Away from the prompt, this technique can be very useful if you want to
write a script that pauses for user interaction, or displays a figure
between polling for additional data.  See <a class="reference internal" href="#interactive-scripts"><span class="std std-ref">Scripts and functions</span></a>
for more details.</p>
</section>
<section id="input-hook-integration">
<h3>Input hook integration<a class="headerlink" href="#input-hook-integration" title="Permalink to this heading">#</a></h3>
<p>While running the GUI event loop in a blocking mode or explicitly
handling UI events is useful, we can do better!  We really want to be
able to have a usable prompt <strong>and</strong> interactive figure windows.</p>
<p>We can do this using the 'input hook' feature of the interactive
prompt.  This hook is called by the prompt as it waits for the user
to type (even for a fast typist the prompt is mostly waiting for the
human to think and move their fingers).  Although the details vary
between prompts the logic is roughly</p>
<ol class="arabic simple">
<li><p>start to wait for keyboard input</p></li>
<li><p>start the GUI event loop</p></li>
<li><p>as soon as the user hits a key, exit the GUI event loop and handle the key</p></li>
<li><p>repeat</p></li>
</ol>
<p>This gives us the illusion of simultaneously having interactive GUI
windows and an interactive prompt.  Most of the time the GUI event
loop is running, but as soon as the user starts typing the prompt
takes over again.</p>
<p>This time-share technique only allows the event loop to run while
python is otherwise idle and waiting for user input.  If you want the
GUI to be responsive during long running code it is necessary to
periodically flush the GUI event queue as described <a class="reference internal" href="#spin-event-loop"><span class="std std-ref">above</span></a>.  In this case it is your code, not the REPL, which
is blocking the process so you need to handle the &quot;time-share&quot; manually.
Conversely, a very slow figure draw will block the prompt until it
finishes drawing.</p>
</section>
</section>
<section id="full-embedding">
<h2>Full embedding<a class="headerlink" href="#full-embedding" title="Permalink to this heading">#</a></h2>
<p>It is also possible to go the other direction and fully embed figures
(and a <a class="reference external" href="https://docs.python.org/3/extending/embedding.html">Python interpreter</a>) in a rich
native application.  Matplotlib provides classes for each toolkit
which can be directly embedded in GUI applications (this is how the
built-in windows are implemented!).  See <a class="reference internal" href="../../gallery/user_interfaces/index.html#user-interfaces"><span class="std std-ref">Embedding Matplotlib in graphical user interfaces</span></a> for
more details.</p>
</section>
<section id="scripts-and-functions">
<span id="interactive-scripts"></span><h2>Scripts and functions<a class="headerlink" href="#scripts-and-functions" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.flush_events</span></code></a></p></td>
<td><p>Flush the GUI events for the figure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.draw_idle</span></code></a></p></td>
<td><p>Request a widget redraw once control returns to the GUI event loop.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/figure_api.html#matplotlib.figure.Figure.ginput" title="matplotlib.figure.Figure.ginput"><code class="xref py py-obj docutils literal notranslate"><span class="pre">figure.Figure.ginput</span></code></a></p></td>
<td><p>Blocking call to interact with a figure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.ginput.html#matplotlib.pyplot.ginput" title="matplotlib.pyplot.ginput"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.ginput</span></code></a></p></td>
<td><p>Blocking call to interact with a figure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.show.html#matplotlib.pyplot.show" title="matplotlib.pyplot.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.show</span></code></a></p></td>
<td><p>Display all open figures.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.pause.html#matplotlib.pyplot.pause" title="matplotlib.pyplot.pause"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.pause</span></code></a></p></td>
<td><p>Run the GUI event loop for <em>interval</em> seconds.</p></td>
</tr>
</tbody>
</table>
<p>There are several use-cases for using interactive figures in scripts:</p>
<ul class="simple">
<li><p>capture user input to steer the script</p></li>
<li><p>progress updates as a long running script progresses</p></li>
<li><p>streaming updates from a data source</p></li>
</ul>
<section id="blocking-functions">
<h3>Blocking functions<a class="headerlink" href="#blocking-functions" title="Permalink to this heading">#</a></h3>
<p>If you only need to collect points in an Axes you can use
<a class="reference internal" href="../../api/figure_api.html#matplotlib.figure.Figure.ginput" title="matplotlib.figure.Figure.ginput"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Figure.ginput</span></code></a> or more generally the tools from
<a class="reference internal" href="../../api/blocking_input_api.html#module-matplotlib.blocking_input" title="matplotlib.blocking_input"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blocking_input</span></code></a> the tools will take care of starting and stopping
the event loop for you.  However if you have written some custom event
handling or are using <a class="reference internal" href="../../api/widgets_api.html#module-matplotlib.widgets" title="matplotlib.widgets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">widgets</span></code></a> you will need to manually run the GUI
event loop using the methods described <a class="reference internal" href="#cp-block-the-prompt"><span class="std std-ref">above</span></a>.</p>
<p>You can also use the methods described in <a class="reference internal" href="#cp-block-the-prompt"><span class="std std-ref">Blocking the prompt</span></a>
to suspend run the GUI event loop.  Once the loop exits your code will
resume.  In general, any place you would use <a class="reference external" href="https://docs.python.org/3/library/time.html#time.sleep" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time.sleep</span></code></a> you can use
<a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.pause.html#matplotlib.pyplot.pause" title="matplotlib.pyplot.pause"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.pause</span></code></a> instead with the added benefit of interactive figures.</p>
<p>For example, if you want to poll for data you could use something like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ln</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[])</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">get_new_data</span><span class="p">()</span>
    <span class="n">ln</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>which would poll for new data and update the figure at 1Hz.</p>
</section>
<section id="explicitly-spinning-the-event-loop">
<span id="spin-event-loop"></span><h3>Explicitly spinning the event Loop<a class="headerlink" href="#explicitly-spinning-the-event-loop" title="Permalink to this heading">#</a></h3>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.flush_events</span></code></a></p></td>
<td><p>Flush the GUI events for the figure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.draw_idle</span></code></a></p></td>
<td><p>Request a widget redraw once control returns to the GUI event loop.</p></td>
</tr>
</tbody>
</table>
<p>If you have open windows that have pending UI
events (mouse clicks, button presses, or draws) you can explicitly
process those events by calling <a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FigureCanvasBase.flush_events</span></code></a>.
This will run the GUI event loop until all UI events currently waiting
have been processed.  The exact behavior is backend-dependent but
typically events on all figure are processed and only events waiting
to be processed (not those added during processing) will be handled.</p>
<p>For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>

<span class="n">ln</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">slow_loop</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">ln</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>  <span class="c1"># to simulate some work</span>
        <span class="n">ln</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>

<span class="n">slow_loop</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">ln</span><span class="p">)</span>
</pre></div>
</div>
<p>While this will feel a bit laggy (as we are only processing user input
every 100ms whereas 20-30ms is what feels &quot;responsive&quot;) it will
respond.</p>
<p>If you make changes to the plot and want it re-rendered you will need
to call <a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_idle</span></code></a> to request that the canvas be
re-drawn.  This method can be thought of <em>draw_soon</em> in analogy to
<a class="reference external" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asyncio.loop.call_soon</span></code></a>.</p>
<p>We can add this to our example above as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">slow_loop</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">ln</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>  <span class="c1"># to simulate some work</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">ln</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(((</span><span class="n">j</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">th</span><span class="p">)))</span>
            <span class="n">ln</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>

        <span class="n">ln</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>

<span class="n">slow_loop</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">ln</span><span class="p">)</span>
</pre></div>
</div>
<p>The more frequently you call <a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FigureCanvasBase.flush_events</span></code></a> the more
responsive your figure will feel but at the cost of spending more
resources on the visualization and less on your computation.</p>
</section>
</section>
<section id="stale-artists">
<span id="id4"></span><h2>Stale artists<a class="headerlink" href="#stale-artists" title="Permalink to this heading">#</a></h2>
<p>Artists (as of Matplotlib 1.5) have a <strong>stale</strong> attribute which is
<a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> if the internal state of the artist has changed since the last
time it was rendered. By default the stale state is propagated up to
the Artists parents in the draw tree, e.g., if the color of a <a class="reference internal" href="../../api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Line2D</span></code></a>
instance is changed, the <a class="reference internal" href="../../api/axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Axes</span></code></a> and <a class="reference internal" href="../../api/figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Figure</span></code></a> that
contain it will also be marked as &quot;stale&quot;.  Thus, <code class="docutils literal notranslate"><span class="pre">fig.stale</span></code> will
report if any artist in the figure has been modified and is out of sync
with what is displayed on the screen.  This is intended to be used to
determine if <code class="docutils literal notranslate"><span class="pre">draw_idle</span></code> should be called to schedule a re-rendering
of the figure.</p>
<p>Each artist has a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Artist.stale_callback</span></code> attribute which holds a callback
with the signature</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Artist</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>which by default is set to a function that forwards the stale state to
the artist's parent.   If you wish to suppress a given artist from propagating
set this attribute to None.</p>
<p><a class="reference internal" href="../../api/figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Figure</span></code></a> instances do not have a containing artist and their
default callback is <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>.  If you call <a class="reference internal" href="../../api/_as_gen/matplotlib.pyplot.ion.html#matplotlib.pyplot.ion" title="matplotlib.pyplot.ion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot.ion</span></code></a> and are not in
<code class="docutils literal notranslate"><span class="pre">IPython</span></code> we will install a callback to invoke
<a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_idle</span></code></a> whenever the
<a class="reference internal" href="../../api/figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Figure</span></code></a> becomes stale.  In <code class="docutils literal notranslate"><span class="pre">IPython</span></code> we use the
<code class="docutils literal notranslate"><span class="pre">'post_execute'</span></code> hook to invoke
<a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_idle</span></code></a> on any stale figures
after having executed the user's input, but before returning the prompt
to the user.  If you are not using <a class="reference internal" href="../../api/pyplot_summary.html#module-matplotlib.pyplot" title="matplotlib.pyplot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyplot</span></code></a> you can use the callback
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Figure.stale_callback</span></code> attribute to be notified when a figure has
become stale.</p>
</section>
<section id="draw-idle">
<span id="idle-draw"></span><h2>Idle draw<a class="headerlink" href="#draw-idle" title="Permalink to this heading">#</a></h2>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw" title="matplotlib.backend_bases.FigureCanvasBase.draw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.draw</span></code></a></p></td>
<td><p>Render the <a class="reference internal" href="../../api/figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Figure</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.draw_idle</span></code></a></p></td>
<td><p>Request a widget redraw once control returns to the GUI event loop.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.flush_events</span></code></a></p></td>
<td><p>Flush the GUI events for the figure.</p></td>
</tr>
</tbody>
</table>
<p>In almost all cases, we recommend using
<a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="matplotlib.backend_bases.FigureCanvasBase.draw_idle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.draw_idle</span></code></a> over
<a class="reference internal" href="../../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.draw" title="matplotlib.backend_bases.FigureCanvasBase.draw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend_bases.FigureCanvasBase.draw</span></code></a>.  <code class="docutils literal notranslate"><span class="pre">draw</span></code> forces a rendering of
the figure whereas <code class="docutils literal notranslate"><span class="pre">draw_idle</span></code> schedules a rendering the next time
the GUI window is going to re-paint the screen.  This improves
performance by only rendering pixels that will be shown on the screen.  If
you want to be sure that the screen is updated as soon as possible do</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">flush_events</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="threading">
<h2>Threading<a class="headerlink" href="#threading" title="Permalink to this heading">#</a></h2>
<p>Most GUI frameworks require that all updates to the screen, and hence
their main event loop, run on the main thread.  This makes pushing
periodic updates of a plot to a background thread impossible.
Although it seems backwards, it is typically easier to push your
computations to a background thread and periodically update
the figure on the main thread.</p>
<p>In general Matplotlib is not thread safe.  If you are going to update
<a class="reference internal" href="../../api/artist_api.html#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Artist</span></code></a> objects in one thread and draw from another you should make
sure that you are locking in the critical sections.</p>
</section>
<section id="eventloop-integration-mechanism">
<h2>Eventloop integration mechanism<a class="headerlink" href="#eventloop-integration-mechanism" title="Permalink to this heading">#</a></h2>
<section id="cpython-readline">
<h3>CPython / readline<a class="headerlink" href="#cpython-readline" title="Permalink to this heading">#</a></h3>
<p>The Python C API provides a hook, <a class="reference external" href="https://docs.python.org/3/c-api/veryhigh.html#c.PyOS_InputHook" title="(in Python v3.10)"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyOS_InputHook</span></code></a>, to register a
function to be run (&quot;The function will be called when Python's
interpreter prompt is about to become idle and wait for user input
from the terminal.&quot;).  This hook can be used to integrate a second
event loop (the GUI event loop) with the python input prompt loop.
The hook functions typically exhaust all pending events on the GUI
event queue, run the main loop for a short fixed amount of time, or
run the event loop until a key is pressed on stdin.</p>
<p>Matplotlib does not currently do any management of <a class="reference external" href="https://docs.python.org/3/c-api/veryhigh.html#c.PyOS_InputHook" title="(in Python v3.10)"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyOS_InputHook</span></code></a> due
to the wide range of ways that Matplotlib is used.  This management is left to
downstream libraries -- either user code or the shell.  Interactive figures,
even with Matplotlib in 'interactive mode', may not work in the vanilla python
repl if an appropriate <a class="reference external" href="https://docs.python.org/3/c-api/veryhigh.html#c.PyOS_InputHook" title="(in Python v3.10)"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyOS_InputHook</span></code></a> is not registered.</p>
<p>Input hooks, and helpers to install them, are usually included with
the python bindings for GUI toolkits and may be registered on import.
IPython also ships input hook functions for all of the GUI frameworks
Matplotlib supports which can be installed via <code class="docutils literal notranslate"><span class="pre">%matplotlib</span></code>.  This
is the recommended method of integrating Matplotlib and a prompt.</p>
</section>
<section id="ipython-prompt-toolkit">
<h3>IPython / prompt_toolkit<a class="headerlink" href="#ipython-prompt-toolkit" title="Permalink to this heading">#</a></h3>
<p>With IPython &gt;= 5.0 IPython has changed from using CPython's readline
based prompt to a <code class="docutils literal notranslate"><span class="pre">prompt_toolkit</span></code> based prompt.  <code class="docutils literal notranslate"><span class="pre">prompt_toolkit</span></code>
has the same conceptual input hook, which is fed into <code class="docutils literal notranslate"><span class="pre">prompt_toolkit</span></code> via the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">IPython.terminal.interactiveshell.TerminalInteractiveShell.inputhook()</span></code>
method.  The source for the <code class="docutils literal notranslate"><span class="pre">prompt_toolkit</span></code> input hooks lives at
<code class="docutils literal notranslate"><span class="pre">IPython.terminal.pt_inputhooks</span></code>.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>A limitation of this design is that you can only wait for one
input, if there is a need to multiplex between multiple sources
then the loop would look something like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fds</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>                    <span class="c1"># Loop</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>   <span class="c1"># Read</span>
        <span class="nb">eval</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>                  <span class="c1"># Evaluate / Print</span>
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="f2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Or you can <a class="reference external" href="https://www.youtube.com/watch?v=ZzfHjytDceU">write your own</a> if you must.</p>
</aside>
<aside class="footnote brackets" id="f3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>These examples are aggressively dropping many of the
complexities that must be dealt with in the real world such as
keyboard interrupts, timeouts, bad input, resource
allocation and cleanup, etc.</p>
</aside>
</aside>
</section>
</section>
</section>


              </article>
              

              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2002–2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012–2022 The Matplotlib development team.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>